-- phpMyAdmin SQL Dump
-- version 5.2.1
-- https://www.phpmyadmin.net/
--
-- Хост: MySQL-8.2
-- Время создания: Июл 19 2024 г., 22:30
-- Версия сервера: 8.2.0
-- Версия PHP: 8.3.6

SET
SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET
time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `DevPortfolioDatabase`
--

-- --------------------------------------------------------

--
-- Структура таблицы `articles`
--

CREATE TABLE `articles`
(
    `id`          int UNSIGNED NOT NULL,
    `user_id`     int UNSIGNED NOT NULL,
    `title`       varchar(255) NOT NULL,
    `description` text,
    `content`     text         NOT NULL,
    `created_at`  timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `updated_at`  timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    `published`   tinyint(1) NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;

--
-- Дамп данных таблицы `articles`
--

INSERT INTO `articles` (`id`, `user_id`, `title`, `description`, `content`, `created_at`, `updated_at`, `published`)
VALUES (17, 1, 'Master of Magic: 30 лет волшебного мастерства.', '',
        'В далёком 1994 году, когда трава была зеленее, девушки сговорчивее, а мана – доступнее, свет увидела игра Master of Magic. На долгие десятилетия игра стала навязчивой идеей многих почитателей компьютерных стратегий, заставших в те далекие годы становление 4Х-жанра.\r\n\r\nТри десятка лет спустя после выхода я продолжаю восхищаться Master of Magic, и думаю, что до сих пор не повидал всего, что она может мне предложить. Конечно, не могу сказать, что играю в нее нон-стоп с момента выпуска, но сама игра всегда установлена на любом моем ПК, а последние десять лет еще и на всех моих смартфонах (спасибо тебе, DosBox).\r\n\r\nПричина в том, что, несмотря на свой скромный по современным меркам размер, ни один другой фэнтезийный 4X-проект пока не смог обогнать её по качеству проработки. Стив Барсия, создавший годом ранее игру Master of Orion, смог опять максимально применить свои талант и мастерство.\r\n\r\nМожет это и недостаточно уважительно, но повесить на Master of Magic ярлык «Цивилизации с дракончиками» могло бы стать неплохим первым шагом. Но сделать так, это все равно, что сказать «Шахматы - игра, где два человека ходят 18 фигурками на клетках пока не победят», а «\"Война и мир\" - книга о Наташе, которая живет, любит и страдает во время войн и мира». То есть никак.\r\n\r\nНе с этого ли мага впоследствии был срисован Саруман на крыльце своей знаменитой башни из экранизации трилогии Толкиена?\r\nНе с этого ли мага впоследствии был срисован Саруман на крыльце своей знаменитой башни из экранизации трилогии Толкиена?\r\nОчень упрощенно процесс игры можно описать следующим образом: ты создаешь себе волшебника, заполняешь книжную полку книгами заклинаний из разных сфер, таких как магия природы, смерти или, скажем, хаоса. Эти книги диктуют направление твоих магических исследований, определяют существ, которых ты можешь призвать, и волшебство, которое ты будешь использовать.\r\n\r\nЧто следовало после такой подготовки? Вы начинали исследовать мир (иначе бы это не был 4Х-жанр). А он буквально переполненный РАЗНЫМ. Мир наполнен руинами, заселенными монстрами пещерами, даже порталами в другое измерение, которое может быть исследовано и даже заселено, если у вас достаточно сил выстоять против странных и могущественных существ, что уже там обитают.\r\n\r\nОчень скоро вы проводите зачистку ближайшей пещеры от летучих тварей, захватывая магический источник на краю города, возвращаясь домой с добычей золота, маны, а если повезет, то и магических предметов. Новые герои приходят к вашему порогу, чтобы предложить свои услуги и испытывают на себе ваши свежие заклинания. Начинается экспансия.\r\n\r\nПрокачанный параллельный мир\r\nПрокачанный параллельный мир\r\nЗахватив несколько соседних городов и призвав множество магических тварей в свои ряды, вы заметите, что ваши армии стали очень и очень толерантными (в пику HoMM, где местные жители ужасные ксенофобы). Так, эльфийские лучники окружены ящерицами-шаманами, за ними стоит великий колосс, а паровая пушка готова в любой момент открыть огонь.\r\n\r\nMaster of Magic совершенно лишен какого-либо чувства меры -  игра содержит сотни заклинаний и сотни юнитов, она полностью позволяет вам комбинировать и перекомбинировать их так легко, будто это конструктор Lego. Это приводило к созданию абсолютно невероятных армий, превращая даже базовые войска в разрушительные силы в определенных ситуациях. Те же Призрачные воины (Phantom Warriors) были простым юнитом, но они могли полностью игнорировать броню своих противников. Было непросто предвидеть, к чему нужно готовиться, и даже самые мощные герои могли оказаться уязвимыми перед определенным заклинанием или юнитом.\r\n\r\nК сожалению, проблема игры заключалась в том, что искусственный интеллект был никакой. Компьютерные волшебники были медленными, слабыми и пассивными, и зачастую являлись не более чем неудобством для сильного игрока-человека.\r\n\r\nОднако главная загадка Master of Magic отнюдь не возможность сыграть за всех волшебников, или изучить весь мир, или получить все артефакты. Главная загадка - почему SimTex так и не успели выпустить сиквел игры? Увы, после объявления Simtex о работе над продолжением (на движке Civ2), они были закрыты. В то время как серии Civilization и Master of Orion продолжались, Master of Magic стала странным эволюционным тупиком. Другие фэнтезийные стратегии, такие как Age of Wonders и Heroes of Might and Magic, никогда не осмеливались быть такими случайными или такими безрассудными.\r\n\r\nКстати, в 1997 году игра даже была портирована на Playstation под названием «Civizard: Majutsu no Keifu». Скажу так – я как-то проходил первую Red Alert на PS1 и скажу вам, было то еще задротство. Как проходить на PS игру такого калибра, как Master of Magic, мне непонятно совершенно. Но факт остаётся фактом.\r\n\r\nСтратегическая карта в порте MoM на PS1 в Civizard: Majutsu no Keifu\r\nСтратегическая карта в порте MoM на PS1 в Civizard: Majutsu no Keifu\r\nКто-то может возразить, сославшись на упоминаемые во всех обзорах Age of Wonders, Elemental: War of Magic, Warlock от Paradox Interactive: Master of the Arcane или Worlds of Magic, но на мой взгляд, это все равно, что сравнивать советский пломбир с современным из «Пятерочки». Не то.\r\n\r\nОднако есть в мире игры и события посущественнее, произошедшие в последние пару лет. В декабре 2022 года вышел ремейк игры с современной графикой, актуальным гексогональным миром (омаж в сторону нового поколения Цивилизаций) и даже новой расой. Но рейтинг игры в 3.5 на gog говорит сам за себя.\r\n\r\nMaster of Magic 2022 - на вкус и цвет, как говорится\r\nMaster of Magic 2022 - на вкус и цвет, как говорится\r\nДругое же событие меня вдохновило больше – ребята с портала Old-Games.Ru перевели игру 1993 года и выпустили её в свет в январе. Рекомендую всем поклонникам серии, душевно.\r\n\r\nРусскоязычная версия 2024 года\r\nРусскоязычная версия 2024 года\r\nВ целом же печально осознавать, что столь безвозвратно и внезапно ушло время игр, создаваемых со столь значительным потенциалом. Сейчас начинается все с монетизации. А когда-то начиналось с идеи. Время это уже не вернуть, а потому пойду и еще раз пройду Master of Magic выпуска далекого, 1994 года.',
        '2024-07-18 14:33:54', '2024-07-19 17:51:31', 1),
       (18, 1,
        'Microsoft Designer доступен на iOS и Android с функциями редактирования и создания контента с помощью ИИ\n',
        NULL,
        'Приложение Microsoft Designer на базе искусственного интеллекта вышло из предварительной версии и доступно всем пользователям iOS и Android. Microsoft Designer позволяет создавать открытки, стикеры, коллажи и многое другое, а также редактировать фото с использованием ИИ.\n\nDesigner находился в предварительной версии почти год. Оно поддерживает стандартные текстовые промпты, а также большой выбор шаблонов для создания различных изображений. Редактирование фото при помощи ИИ позволит изменять или удалять фон, людей и предметы с фото, добавлять текст, рамки и другие декоративные элементы. \n\n\nMicrosoft Designer доступен и как отдельное приложение, и через Copilot в таких приложениях, как Word и PowerPoint. Подписчики Copilot Pro могут создавать изображения с помощью Designer прямо в своей рабочей среде. \n\nMicrosoft также сообщила, что Designer участники инсайдерской программы Windows получат доступ к Designer в приложении «Фотографии» в Windows 11. Им будут доступны такие функции, как удаление объектов, фона, автоматическая обрезка и фильтры прямо в приложении «Фотографии».',
        '2024-07-18 14:33:54', '2024-07-18 18:44:46', 1),
       (19, 1, 'Master of Magic: 30 лет волшебного мастерства\n', NULL,
        'В далёком 1994 году, когда трава была зеленее, девушки сговорчивее, а мана – доступнее, свет увидела игра Master of Magic. На долгие десятилетия игра стала навязчивой идеей многих почитателей компьютерных стратегий, заставших в те далекие годы становление 4Х-жанра.\n\nТри десятка лет спустя после выхода я продолжаю восхищаться Master of Magic, и думаю, что до сих пор не повидал всего, что она может мне предложить. Конечно, не могу сказать, что играю в нее нон-стоп с момента выпуска, но сама игра всегда установлена на любом моем ПК, а последние десять лет еще и на всех моих смартфонах (спасибо тебе, DosBox).\n\nПричина в том, что, несмотря на свой скромный по современным меркам размер, ни один другой фэнтезийный 4X-проект пока не смог обогнать её по качеству проработки. Стив Барсия, создавший годом ранее игру Master of Orion, смог опять максимально применить свои талант и мастерство.\n\nМожет это и недостаточно уважительно, но повесить на Master of Magic ярлык «Цивилизации с дракончиками» могло бы стать неплохим первым шагом. Но сделать так, это все равно, что сказать «Шахматы - игра, где два человека ходят 18 фигурками на клетках пока не победят», а «\"Война и мир\" - книга о Наташе, которая живет, любит и страдает во время войн и мира». То есть никак.\n\nНе с этого ли мага впоследствии был срисован Саруман на крыльце своей знаменитой башни из экранизации трилогии Толкиена?\nНе с этого ли мага впоследствии был срисован Саруман на крыльце своей знаменитой башни из экранизации трилогии Толкиена?\nОчень упрощенно процесс игры можно описать следующим образом: ты создаешь себе волшебника, заполняешь книжную полку книгами заклинаний из разных сфер, таких как магия природы, смерти или, скажем, хаоса. Эти книги диктуют направление твоих магических исследований, определяют существ, которых ты можешь призвать, и волшебство, которое ты будешь использовать.\n\nЧто следовало после такой подготовки? Вы начинали исследовать мир (иначе бы это не был 4Х-жанр). А он буквально переполненный РАЗНЫМ. Мир наполнен руинами, заселенными монстрами пещерами, даже порталами в другое измерение, которое может быть исследовано и даже заселено, если у вас достаточно сил выстоять против странных и могущественных существ, что уже там обитают.\n\nОчень скоро вы проводите зачистку ближайшей пещеры от летучих тварей, захватывая магический источник на краю города, возвращаясь домой с добычей золота, маны, а если повезет, то и магических предметов. Новые герои приходят к вашему порогу, чтобы предложить свои услуги и испытывают на себе ваши свежие заклинания. Начинается экспансия.\n\nПрокачанный параллельный мир\nПрокачанный параллельный мир\nЗахватив несколько соседних городов и призвав множество магических тварей в свои ряды, вы заметите, что ваши армии стали очень и очень толерантными (в пику HoMM, где местные жители ужасные ксенофобы). Так, эльфийские лучники окружены ящерицами-шаманами, за ними стоит великий колосс, а паровая пушка готова в любой момент открыть огонь.\n\nMaster of Magic совершенно лишен какого-либо чувства меры -  игра содержит сотни заклинаний и сотни юнитов, она полностью позволяет вам комбинировать и перекомбинировать их так легко, будто это конструктор Lego. Это приводило к созданию абсолютно невероятных армий, превращая даже базовые войска в разрушительные силы в определенных ситуациях. Те же Призрачные воины (Phantom Warriors) были простым юнитом, но они могли полностью игнорировать броню своих противников. Было непросто предвидеть, к чему нужно готовиться, и даже самые мощные герои могли оказаться уязвимыми перед определенным заклинанием или юнитом.\n\nК сожалению, проблема игры заключалась в том, что искусственный интеллект был никакой. Компьютерные волшебники были медленными, слабыми и пассивными, и зачастую являлись не более чем неудобством для сильного игрока-человека.\n\nОднако главная загадка Master of Magic отнюдь не возможность сыграть за всех волшебников, или изучить весь мир, или получить все артефакты. Главная загадка - почему SimTex так и не успели выпустить сиквел игры? Увы, после объявления Simtex о работе над продолжением (на движке Civ2), они были закрыты. В то время как серии Civilization и Master of Orion продолжались, Master of Magic стала странным эволюционным тупиком. Другие фэнтезийные стратегии, такие как Age of Wonders и Heroes of Might and Magic, никогда не осмеливались быть такими случайными или такими безрассудными.\n\nКстати, в 1997 году игра даже была портирована на Playstation под названием «Civizard: Majutsu no Keifu». Скажу так – я как-то проходил первую Red Alert на PS1 и скажу вам, было то еще задротство. Как проходить на PS игру такого калибра, как Master of Magic, мне непонятно совершенно. Но факт остаётся фактом.\n\nСтратегическая карта в порте MoM на PS1 в Civizard: Majutsu no Keifu\nСтратегическая карта в порте MoM на PS1 в Civizard: Majutsu no Keifu\nКто-то может возразить, сославшись на упоминаемые во всех обзорах Age of Wonders, Elemental: War of Magic, Warlock от Paradox Interactive: Master of the Arcane или Worlds of Magic, но на мой взгляд, это все равно, что сравнивать советский пломбир с современным из «Пятерочки». Не то.\n\nОднако есть в мире игры и события посущественнее, произошедшие в последние пару лет. В декабре 2022 года вышел ремейк игры с современной графикой, актуальным гексогональным миром (омаж в сторону нового поколения Цивилизаций) и даже новой расой. Но рейтинг игры в 3.5 на gog говорит сам за себя.\n\nMaster of Magic 2022 - на вкус и цвет, как говорится\nMaster of Magic 2022 - на вкус и цвет, как говорится\nДругое же событие меня вдохновило больше – ребята с портала Old-Games.Ru перевели игру 1993 года и выпустили её в свет в январе. Рекомендую всем поклонникам серии, душевно.\n\nРусскоязычная версия 2024 года\nРусскоязычная версия 2024 года\nВ целом же печально осознавать, что столь безвозвратно и внезапно ушло время игр, создаваемых со столь значительным потенциалом. Сейчас начинается все с монетизации. А когда-то начиналось с идеи. Время это уже не вернуть, а потому пойду и еще раз пройду Master of Magic выпуска далекого, 1994 года.',
        '2024-07-18 14:33:54', '2024-07-18 18:45:14', 1),
       (20, 1, 'Telegram bot, взаимодействующий с API OpenAI без проксирования. Разработка на Python\n', NULL,
        'Создадим бота, использующего API OpenAI. И так развернем его на сервере, чтобы не настраивать проксирование запросов к API OpenAI (который заблокирован для пользователей из России), и не использовать иностранные VPS.\n\nБот должен помогать осуществлять\n\nАвтоматизацию рутинных задач (написание кода, документации, тестов).\n\nПредоставлять рекомендации и примеры кода.\n\nАнализировать код, находить ошибки и давать предложения по улучшению.\n\nСокращать времени разработки и тестирования.\n\nПланирование и дизайн бота\nФункциональные требования:\n\nПриветственное сообщение при запуске.\n\nГенерация ответов через OpenAI API.\n\nОбработка команд, например, /bot или /start\n\nЛогирование ошибок.\n\nАвтоматическое повторное подключение при сбое.\n\nОсновные сценарии использования\nЗапуск бота:\n\nПользователь запускает бота командой /start.\n\nБот отправляет приветственное сообщение.\n\nЗапрос информации:\n\nПользователь отправляет команду /bot или любое текстовое сообщение.\n\nБот генерирует ответ с помощью OpenAI API и отправляет его пользователю.\n\nОбработка ошибок:\n\nВ случае ошибки бот записывает ее в лог и пытается восстановить соединение.\n\nВыбор технологий и инструментов\nМы будем использовать следующие технологии и инструменты:\n\nPython: Простота и легкость в изучении, большое количество библиотек и инструментов.\n\nTeleBot: Простой интерфейс для взаимодействия с Telegram API.\n\nOpenAI API: Использование модели GPT-3.5 для генерации текстовых ответов.\n\nНаписание кода телеграм-бота\nБот включает в себя несколько ключевых компонентов, которые обеспечивают его функциональность и взаимодействие с пользователями:\n\nTelegram Bot API: Этот компонент отвечает за прием и отправку сообщений пользователям через платформу Telegram.\n\nOpenAI API: Используется для генерации ответов на запросы пользователей с помощью модели GPT-3.5.\n\nЛогирование: Ведет запись событий и ошибок для последующего анализа и отладки.\n\nОсновной цикл (Event Loop): Обеспечивает непрерывную работу бота и обработку всех входящих сообщений.\n\nЭти компоненты взаимодействуют следующим образом:\n\nПользователь отправляет сообщение боту в Telegram.\n\nБот принимает сообщение через Telegram Bot API и отправляет запрос к OpenAI API для генерации ответа.\n\nПолученный ответ возвращается пользователю через Telegram.\n\nВсе события и ошибки записываются в лог для мониторинга и отладки.\n\n1. Инициализация бота и API ключей OpenAI\nСначала необходимо настроить API ключи для OpenAI и Telegram.\n\nimport openai\nimport telebot\nimport logging\nimport os\nimport time\n\nopenai.api_key = \'Ваш Openai API ключ\'\nbot = telebot.TeleBot(\'Ваш Telegram токен\')\nЗдесь мы импортируем необходимые библиотеки и устанавливаем ключи для доступа к API OpenAI и Telegram.\n\n2. Настройка логирования\nЛогирование позволяет отслеживать события и ошибки в работе бота.\n\nlog_dir = os.path.join(os.path.dirname(__file__), \'ChatGPT_Logs\')\nif not os.path.exists(log_dir):\n    os.makedirs(log_dir)\nlogging.basicConfig(filename=os.path.join(log_dir, \'error.log\'), level=logging.ERROR,\n                    format=\'%(levelname)s: %(asctime)s %(message)s\', datefmt=\'%d/%m/%Y %H:%M:%S\')\nМы создаем директорию для логов и настраиваем параметры логирования для удобства анализа.\n\n3. Обработка команд и сообщений\nОпределим функции для обработки команд /start и /bot, а также любых текстовых сообщений.\n\n@bot.message_handler(commands=[\'start\'])\ndef send_welcome(message):\n    bot.reply_to(message, \'Привет!\\nЯ ChatGPT 3.5 Telegram Bot\\U0001F916\\nЗадай мне любой вопрос и я постараюсь на него ответить\')\n\ndef generate_response(prompt):\n    completion = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    return completion.choices[0].message.content\n\n@bot.message_handler(commands=[\'bot\'])\ndef command_message(message):\n    prompt = message.text\n    response = generate_response(prompt)\n    bot.reply_to(message, text=response)\n\n@bot.message_handler(func=lambda _: True)\ndef handle_message(message):\n    prompt = message.text\n    response = generate_response(prompt)\n    bot.send_message(chat_id=message.from_user.id, text=response)\nsend_welcome: Отправляет приветственное сообщение при запуске бота.\n\ngenerate_response: Генерирует ответ с помощью OpenAI API.\n\ncommand_message и handle_message: Обрабатывают команды и текстовые сообщения, генерируя ответы с помощью OpenAI API.\n\n4. Основной цикл\nЗапуск основного цикла для обработки сообщений и повторного подключения при сбоях.\n\nprint(\'ChatGPT Bot is working\')\n\nwhile True:\n    try:\n        bot.polling()\n    except (telebot.apihelper.ApiException, ConnectionError) as e:\n        logging.error(str(e))\n        time.sleep(5)\n        continue\nЗдесь мы запускаем основной цикл, который постоянно проверяет новые сообщения и обрабатывает их. В случае ошибки бот записывает ее в лог и пытается восстановить соединение.\n\nПолучаем готовый код для нашего бота\n\nimport openai\nimport telebot\nimport logging\nimport os\nimport time\n\nopenai.api_key = \'Openai_api_key\'\nbot = telebot.TeleBot(\'Telegram_token\')\n\nlog_dir = os.path.join(os.path.dirname(__file__), \'ChatGPT_Logs\')\n\nif not os.path.exists(log_dir):\n    os.makedirs(log_dir)\n\nlogging.basicConfig(filename=os.path.join(log_dir, \'error.log\'), level=logging.ERROR,\n                    format=\'%(levelname)s: %(asctime)s %(message)s\', datefmt=\'%d/%m/%Y %H:%M:%S\')\n\n@bot.message_handler(commands=[\'start\'])\ndef send_welcome(message):\n    bot.reply_to(message, \'Привет!\\nЯ ChatGPT 3.5 Telegram Bot\\U0001F916\\nЗадай мне любой вопрос и я постараюсь на него ответиь\')\n\ndef generate_response(prompt):\n        completion = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n        )\n        return completion.choices[0].message.content\n\n\n@bot.message_handler(commands=[\'bot\'])\ndef command_message(message):\n    prompt = message.text\n    response = generate_response(prompt)\n    bot.reply_to(message, text=response)\n\n\n@bot.message_handler(func = lambda _: True)\ndef handle_message(message):\n    prompt = message.text\n    response = generate_response(prompt)\n    bot.send_message(chat_id=message.from_user.id, text=response)\n\n\nprint(\'ChatGPT Bot is working\')\n\nwhile True:\n    try:\n        bot.polling()\n    except (telebot.apihelper.ApiException, ConnectionError) as e:\n        logging.error(str(e))\n        time.sleep(5)\n        continue\nРазвертывание на сервер c доступом к API OpenAI\nДля развертывания мы остановимся на платформе Amvera.\n\nПочему выбрали Amvera?\n\nAmvera предоставляет встроенное бесплатное проксирование до API OpenAI. Вам не потребуется зарубежная виртуальная машина или VPN.\n\nРазвертывание идет максимально просто. Через загрузку кода в интерфейсе, либо через git push.\n\nСтартовый баланс, который позволит протестировать сервис.\n\nЗапускаем нашего бота в облаке\nПерейдем теперь к самой интересной части данной статьи, как развернуть бота так, чтобы не использовать иностранные серверы и не настраивать проксирование к API OpenAI.\n\nРегистрация в сервисе\nНа сайте Amvera нажимаем на кнопку \"Регистрация\".\n\nЗаполняем последовательно все поля.\n\nПодтверждаем, что мы не робот, и тыкаем на большую синюю кнопку \"Регистрация\"\n\nОстается только подтвердить указанную почту, перейдя по ссылке в письме.\n\nСоздание проекта и размещение бота\nНа появившейся после входа странице нажимаем на кнопку \"Создать\" или \"Создать первый!\".\n\nВыбираем тариф. Может показаться, что тарифные планы предоставляют слишком мало ресурса по сравнению с VPS. Однако в VPS часть ресурсов используется операционной системой, а тут весь выделенный ресурс уходит только на развертываемое приложение. Нам хватит тарифа Пробный, но первый запуск лучше осуществить на одном из старших тарифов, чтобы убедиться, что все работает.\n\nОкно создания нового проекта\nОкно создания нового проекта\nСоздадим конфигурационный yaml файл. Это можно сделать самостоятельно на основании документации, однако я рекомендую воспользоваться автоматическим графическим инструментом генерации либо сделать это в личном кабинете во вкладке Конфигурация.\n\nГрафический инструмент генерации .yaml файлов\nГрафический инструмент генерации .yaml файлов\nМы используем Python, укажем его версию.\n\nrequirements.txt - файл с зависимостями. Очень важно указать все используемые в проекте библиотеки в этом файле, чтобы сервис смог их скачать через pip. Необходимо прописать все библиотеки в формате библиотека==версия.\n\nУказываем путь до файла, содержащего точку входа в программу (тот файл, который вы указываете интерпретатору питона, когда запускаете приложение) либо команду запуска.\n\nЕсли в процессе работы ваш бот использует SQLite, сохраняйте данные в постоянное хранилище /data. В противном случае при перезапуске проекта все данные будут потеряны!\n\nПорт можно указать тот, который используется в коде вашего приложения. Не забудьте изменить локалхост на 0.0.0.0\n\nНажимаем на кнопку Generate YAML, после чего начинается загрузка файла amvera.yml.\n\nСкачанный файл кладем в корень нашего проекта\n\nИнициируем Git-репозиторий и загружаем наш проект.\n\nВ корне нашего проекта выполняем команду: git init (если гит уже инициализирован в вашем проекте, то этого делать не нужно)\n\nПривязываем наш локальный гит репозиторий к удаленному репозиторию через команду, которая указана на странице проекта в amvera (имеет формат git remote add amvera <https://git.amvera.ru/ваш_юзернейм/ваш_проект>)\n\nДелаем git add . и git commit -m \"Initial commit\"\n\nДелаем push с нашим проектом, выполняя команду git push amvera master, вводя учетные данные, которые использовались при регистрации в сервисе.\n\nПосле того как проект запушится в систему, на странице проекта статус поменяется на \"Выполняется сборка\".\n\nУспешно развернутый проект\nУспешно развернутый проект\nКак только проект соберется, он перейдет в стадию: \"Выполняется развертывание\", а после в статус \"Успешно развернуто\".\n\nУспешно развернутый проект\nУспешно развернутый проект\nЕсли по какой-то причине проект не развернулся, можно обратиться к логам сборки и логам приложения для отладки. Если Проект завис в статусе \"Сборка\" на долгое время, а логи сборки не отображаются, то стоит ещё раз проверить корректность amvera.yml файла.\n\nУра, все работает! Теперь наш Telegram-бот развернут и готов к использованию. Вы можете проделать все шаги из статьи и протестировать его, отправив команды и сообщения, чтобы увидеть, как он работает с API OpenAI.\n\nАвтор материала: Алексей Пономарёв',
        '2024-07-18 14:33:54', '2024-07-18 18:45:41', 1),
       (21, 1, 'Для игры «Смута» и бесплатного режима «Смутное время» вышли новые патчи', NULL,
        'Компания «Сайберия нова» выпустила два новых патча. Первый версии 1.0.9 для игры «Смута», второй версии 1.1.0 для бесплатного режима «Смутное время». Патч для бесплатного режима расширяет проект добавлением «Тренировочного лагеря», где игрок сможет познакомиться с боевой системой игры, а для игры «Смута» выпущен объёмный патч с большим списком изменений.\n\n\nВ список изменений патча 1.0.9 для игры «Смута» вошли:\n\nдобавлена финальная редактура субтитров, включая исправления орфографических, пунктуационных и логических ошибки текстов;\n\nисправлена проблема, приводившая к вылетам игры из‑за неправильных ключей локализации;\n\nна локации «Сказочный лес» добавлены бочки с водой для восполнения здоровья;\n\nубран лимит прокачки главного героя;\n\nизменено поведение лошади ночью (в том числе при попадании в засаду);\n\nпроизведена проверка локаций на проходимость на лошади ночью;\n\nисправлена проблема, при которой бой начинался сразу после завершения катсцены;\n\nрасставлены диалоговые NPC на дорогах (Ярославль, Тёплый Стан, Лагерь Ополчения под Москвой);\n\nисправлена анимация с факелом и лошадью.\n\nпроведена оптимизация шейдеров окружения;\n\nрешены проблемы с ландшафтом у реки на локации Ярославль;\n\nисправлена проблема, когда у модели пленного Кручины присутствовал пистоль;\n\nустранена проблема, при которой во время диалога с персонажами они смотрели вбок либо не поворачивались лицом к Юрию;\n\nпроведена общая перенастройка боевой системы.\n\nС полным списком изменений в игре можно ознакомиться здесь.\n\nВ список изменений патча 1.1.0 для режима » Смутное время» вошли:\n\nдобавлена локация Тренировочный лагерь»;\n\nрешена проблема, при которой при закрытии клиента игры выставленный уровень сложности не сохранялся;\n\nисправлена проблема отсутствия объектов при установленных коллизиях (невидимые объекты и препятствия).\n\nС полным списком изменений режима можно ознакомиться здесь ',
        '2024-07-18 14:33:54', '2024-07-18 18:46:03', 1),
       (22, 1, 'Островок (из серии «Кукарямба»)\n', NULL,
        'Свой островок есть в любой конторе. Был он и в Кукарямбе, а назывался он \"Сахалин\". Заведовал им всесильный Филя, который был огромным косматым мужиком в драном свитере и неопрятной бородой, именно таким, каким в те годы представляли программистов — людей, имеющих какое-либо отношение к офисной технике.\n\nФиля появился в Кукарямбе одним из первых, был чуть ли не первым разработчиком и долгое время один выполнял все функции, которые в наше время уже никто не делает вручную, а именно: вел контроль версий, прогонял юнит-тесты, строил тестовые сборки, проводил статический анализ кода, делал код-ревью и еще много чего. Ему, как главному на хозяйстве, разработчики присылали свои изменения в виде зипов, а он единолично решал, что с этими изменениями делать. Бывало, Филя смотрел изменения, присланные ему, и оставался доволен, отвечая коротким \"саундс гут\", бывало, возвращал с резолюцией: \"Вызывает отвращение, переписать!\".\n\nДо поры до времени все было замечательно, сборки собирались, версии выкладывались и все, в том числе наш КуКаРя-менеджмент, были счастливы. Так из морской пены родился наш продукт, основной частью которого была библиотека отрисовки картографического контента \"Сахалин\".\n\nФиля был полноправным и единоличным, как бы это сейчас сказали, \"владельцем\" \"Сахалина\". Чужих в свой огород он не пускал, поскольку \"Сахалин\" представлял собой довольно сложное и запутанное существо, со множеством макросов, ассемблерных вставок и самогенерирующихся \"чертей\". Чтобы оценить степень отрешенности \"Сахалина\" от остального мира, стоит заметить, что собирался он только на Филиной машине. Еще, по слухам, он содержал где-то в своих недрах тетрис, выполнявшийся прямо на видеокарте, но на все распросы Филя таинственно молчал, не подтверждая, но и не опровергая слухи.\n\nИ все бы было хорошо, если бы Филя не уехал однажды в Америку. Я даже помню этот пасмурный день, была среда, шел мерзкий питерский дождик. Филя пришел утром и с порога сказал:\n\n— Баста, карапузики, кончились танцы!\n\n— Что так? — не поняли мы.\n\n— Уезжаю, господа!\n\n— Куда?\n\n— В Америку, куда еще?\n\nИ Филя уехал. А \"Сахалин\" остался.\n\nПочти год его никто не трогал, он тихо собирался на оставленном Филей компе, стоявшем теперь в кабинете начальника разработки, перегружать который было строго-настрого запрещено.\n\nПостепенно как-то все стали забывать о существовании \"Сахалина\", поскольку добавления новых фич он не требовал, попадая таким, каким его оставил Филя, во все версии продуктов.\n\nНо через полтора года одна международная организация анонсировала новую версию стандарта, который требовал существенно изменить логику рисования.\n\nВспомнив о \"Сахалине\", менеджмент предложил Филе в Америке подработать, но, по слухам, тот отказался.\n\n\"Ну и ладно, — сказал менеджмент, — мы сами\".\n\nПервые попытки пропатчить \"Сахалин\" не увенчались успехом. После полугода ковыряния в его потрохах он что-то рисовал, надолго подлипая в ассемблерных вставках, часто падал, валя машину в синий экран. После очередного патча синий экран ушел, но вместо этого он стал слегка поджирать память в драйвере, так что после пяти суток работы всю машину приходилось перегружать, перегрузка апликухи не помогала.\n\nСроки поджимали, менеджмент собрал кризисный митинг, единственным решением которого было то, что \"Сахалин — это последний шит\". Стабильность \"Сахалина\" от этого, естественно, не улучшилась.\n\nВ курилке начались разговоры о \"технических долгах\", о переходе под Линукс, где все \"просто и понятно\", к фиговой работе \"Сахалина\" стали привыкать, теперь любой баг можно было списать на \"Сахалин\", сказав, что \"с этим ничего не сделать\" или \"обращайтесь в Америку\". Филино имя вслух произносить никто не решался.\n\nЕстественно, такая жизнь со временем стала реально всем мешать, и менеджмент принял непростое решение написать новый \"Сахалин\", а старый выбросить.\n\nРешить было легче, чем написать. Новую библиотеку назвали гордым словом \"Манхэттен\", когда с америкосами отношения были еще туда-сюда, сейчас бы ее, наверное, назвали \"Валаам\" или \"Котлин\", \"Котлин\" тогда еще не был занят.\n\nМесяца полтора спецы из \"core\" группы, мы их называли \"кожура\", кумекали, рисовали на стенах гигантские UML-и с тысячами сущностей, писали документы, что-то лабали ежедневно до десяти часов вечера и к концу второго месяца с большой помпой показали демку. Демка реализовывала примерно полпроцента того, что мог старый \"Сахалин\", использовала два десятка сторонних, \"серых\" библиотек и при работе грузила проц на сто процентов, чем, естественно, большого энтузиазма у народа не вызвала.\n\nДальше прожорливой демки дело с \"Манхэттеном\" не пошло, несмотря на то, что лид \"кожуры\" при каждом удобном случае говорил, что \"Манхэттен\" — это \"будущее\", и что \"гибкость в нем сочетается со здравым смыслом\". \"Будущее\" еще немного поваландали на митингах и забыли.\n\nДавить \"Сахалин\" по капле, переписывая и заменяя его маленькими кусочками, тоже не получилось. За десять лет он проник практически в каждый модуль, крепко держась там своими, порой с десятком параметров, функциями, пронизывая собой приложения снизу доверху.\n\nПри этом каждый новый начальник с энтузиазмом обещал при назначении выбросить эту \"легасню\", но начальники приходили и уходили, а \"легасня\" оставалась.\n\nЗа время, прошедшее с момента ухода Фили, с \"Сахалином\" научились обращаться. Его научились собирать в специальном контейнере, который, кстати, назвали \"Степашка\". При работе приложение обложили со всех сторон злобными \"вотчерами\", обнулявшими и перезапускавшими все, что только можно, при первых симптомах сбоя.\n\nКазалось, что так будет вечно, пока в какой-то момент \"Сахалин\" не перестал рисовать. То есть совсем. Это напоминало остановившиеся часы на стене дома в Хиросиме. \"Сахалин\" застыл в 16:46 по московскому времени, нарисовав в последний раз топографическую сетку и масштаб. Я точно не помню, чем тогда закончилась история, но помню, что через две недели у нас уже был новый начальник.\n\nТак случилось, что я ушел из компании и надолго забыл о \"Сахалине\". Я поддерживал дружеские отношения со своими бывшими коллегами, хотя уже давно живу в другой стране. За это время сменились технологии и мода на них, на рынке появлялись и исчезали продукты и бренды. И вот совсем недавно волей случая я оказался на специализированной выставке, участие в которой принимала та самая компания.\n\nПо старой памяти я подошел к стенду. Это были молодые и совсем незнакомые мне люди. Они с готовностью начали рассказывать о новом продукте, махая руками и в уме прикидывая, кто я и откуда, пока я не попросил их показать мне каталог bin.\n\nЖаль, что этого не видел Филя.',
        '2024-07-18 14:33:54', '2024-07-18 18:46:25', 1),
       (23, 1,
        'Nvidia объявила о старте летней распродажи: в GeForce Now 9 новых игр, а сам сервис доступен со скидкой 50%\n',
        NULL,
        'С 18 июля по 18 августа в GeForce Now проходит летняя распродажа. В это врем подписка на GeForce Now Priority или Ultimate на один или шесть месяцев доступна со скидкой 50%. Кроме того, в сервисе появилось 9 новых игр.\n\n\nNvidia напоминает, что у подписчиков Priority есть преимущества по сравнению с бесплатными пользователями, включая более быстрый доступ к игровым серверам и игровым сеансам продолжительностью до шести часов. Им также доступна трассировка лучей на несколько устройств с включённым RTX.\n\nУровень Ultimate предоставляет участникам эксклюзивный доступ к серверам и возможность потоковой передачи с разрешением до 4K и частотой 120 кадров в секунду или до 240 кадров в секунду без обновления оборудования. \n\n«Подписчики Ultimate получают все преимущества, которые есть у владельцев графических процессоров серии GeForce RTX 40, включая NVIDIA DLSS 3 для максимально плавной частоты кадров и NVIDIA Reflex для потоковой передачи с минимальной задержкой», — пишет Nvidia.\n\nТакже в сервисе появилось девять новых игр:\n\nThe Crust (релиз в Steam 15 июля);\n\nGestalt: Steam & Cinder (релиз в Steam 16 июля);\n\nNobody Wants to Die (релиз в Steam 17 июля);\n\nDungeons of Hinterberg (новинка в Steam (релиз от 18 июля) и на Xbox, доступна через PC Game Pass);\n\nFlintlock: The Siege of Dawn (новинка в Steam (релиз от 18 июля) и на Xbox, доступна через PC Game Pass);\n\nNorland (релиз в Steam 18 июля);\n\nKunitsu-Gami: Path of the Goddess  (релиз в Steam 19 июля);\n\nContent Warning;\n\nCrime Boss: Rockay City.',
        '2024-07-18 14:33:54', '2024-07-18 18:46:47', 1),
       (24, 1, 'OpenAI представила новую бесплатную модель GPT-4o-mini, она заменит GPT-3.5 Turbo\n', NULL,
        'OpenAI представила GPT-4o mini, небольшую ИИ-модель, которая призвана сделать технологии компании более доступными и менее энергоёмкими. Использование GPT-4o mini обойдётся в 15 центов за миллион входных токенов и 60 центов за миллион выходных токенов; это на 60% дешевле, чем цена GPT-3.5 Turbo.\n\nНовая модель уже доступна пользователям ChatGPT Free, Plus и Team. Корпоративные пользователи получат доступ начиная со следующей недели, сообщает OpenAI.\n\nПо данным OpenAI, пока GPT-4o mini поддерживает текст и изображение в API, поддержка других форматов, включая распознавание голоса, появится в будущем. Модель может похвастаться контекстным окном в 128 000 токенов, до 16 000 токенов вывода на каждый запрос и знаниями до октября 2023 года.\n\nКомпания утверждает, что новая модель превосходит стандартную модель GPT-4 при использовании в качестве чат-бота. В испытаниях GPT-4o mini набрала 82% по тесту MMLU (тест на интеллект и рассуждения, который используется для оценки возможностей языковых моделей. Чем выше балл MMLU, тем лучше ИИ понимает   использует естественный язык., что расширяет возможности его использования в реальной жизни). OpenAI отмечает, что результаты GPT-4o mini сравнимы с 77,9% у Gemini Flash от Google и 73,8% у Claude Haiku от Anthropic.\n\n\nOpenAI также заявила, что GPT-4o mini — это первая модель искусственного интеллекта компании, в которой используется новая тактика безопасности под названием «иерархия инструкций». Цель этого подхода — заставить ИИ отдавать приоритет некоторым инструкциям (например, инструкциям компании) над другими, чтобы людям было сложнее заставить инструмент делать то, чего он не должен.\n\n13 мая OpenAI представила языковую модель GPT-4o, которая легла в основу ChatGPT. GPT-4o может воспринимать и генерировать звук, изображение и текст и будет доступна всем пользователям бесплатно. \n\nО в GPT-4o означает omni, что должно отражать универсальность её работы. Эта версия «намного быстрее» предшественниц и занимает первое место по всем тестам по сравнению с конкурентами, включая Google Gemini.  В ходе демонстрации GPT-4o сотрудники OpenAI пообщались с ней голосом, продемонстрировав её умение понимать тон и направление беседы и то, как естественно она разговаривает и даже шутит. Её также попросили сымитировать типичный голос робота, с чем она также справилась.',
        '2024-07-18 14:33:54', '2024-07-18 18:47:03', 1);
INSERT INTO `articles` (`id`, `user_id`, `title`, `description`, `content`, `created_at`, `updated_at`, `published`)
VALUES (25, 1, 'Руководство по Apache Spark не для начинающих: оптимизация\n', NULL,
        'В прошлой статье SPARK для «малышей» я писал о возможностях и функциях Apache Spark для обработки данных. Мы сосредоточились на ключевых функциях чтения, обработки и сохранения данных, не забывая о примерах кода, которые помогут новичкам быстро включиться в работу.\n\nВ этой статье мы пойдём глубже и рассмотрим оптимизацию. Сосредоточимся на базовых концепциях, оптимизации запросов и соединениях. Конечно же, с примерами.\n\n\n[Оглавление]\n\nЗачем оптимизировать Spark?\n\n№1. Базовые концепции оптимизации\n\n— Схема данных\n— Кеширование и персистенция\n— Управление партициями\n\n№2. Оптимизация запросов\n\nВыбор правильных операций\n— Трансформации\n— Действия\n— Принцип ленивых вычислений\n— Как выбрать правильные операции\n— Использование map и flatMap\n— Использование reduceByKey и groupByKey\n\nПорядок выполнения операций\n— Важность выполнения фильтрации и агрегации до соединений\n— Стратегии построения запросов от меньших таблиц к большим\n— Различные стратегии для уменьшения данных до соединения\n\nЗачем оптимизировать Spark?\nДля этого есть несколько веских причин.\n\nСокращение времени выполнения задач.\n\nОптимизация позволяет значительно уменьшить время, необходимое для выполнения различных вычислительных операций. Это особенно важно для обработки больших объёмов данных, где даже небольшие улучшения могут приводить к значительному сокращению времени выполнения.\n\nПовышение эффективности использования ресурсов.\n\nОптимизация помогает более эффективно использовать вычислительные ресурсы, такие как процессорное время и оперативная память. Это позволяет обрабатывать больше данных с меньшими затратами и предотвращает перегрузку системы.\n\nУлучшение производительности приложений.\n\nОптимизированные Spark-приложения выполняются быстрее и с меньшими задержками. Это особенно важно для приложений реального времени, где скорость обработки данных имеет критическое значение.\n\nСнижение затрат.\n\nЭффективное использование ресурсов также приводит к снижению затрат на инфраструктуру, так как требуется меньше вычислительных мощностей и памяти для обработки тех же объёмов данных.\n\nСтабильность и надёжность.\n\nОптимизация помогает избежать проблем с производительностью, таких как затыки и падения, что делает системы более стабильными и надёжными в работе.\n\nМасштабируемость.\n\nОптимизированные решения легче масштабировать, так как они используют ресурсы более эффективно и могут обрабатывать увеличивающиеся объёмы данных без существенного увеличения времени выполнения.\n\nТаким образом, оптимизация Apache Spark не только ускоряет выполнение задач и улучшает общую производительность системы, но и помогает снижать операционные расходы, повышать надёжность и масштабируемость решений.\n\nПерейдём к концепциям.\n\n№1. Базовые концепции оптимизации\nВ эту главу входят: схема данных, кэширование и персистенция, управление партициями. Начнём со схемы данных.\n\nСхема данных\nОптимизация Apache Spark начинается с эффективного управления схемой данных. Это одна из ключевых концепций, которая значительно влияет на производительность ваших приложений.\n\nИспользование схемы вместо автоматического определения типов\nПо умолчанию, Spark может автоматически определять типы данных при чтении файлов, таких как CSV, JSON и Parquet. Это удобно для быстрой разработки. Однако, автоматическое определение типов данных (schema inference) может негативно сказаться на производительности. \n\nВот почему:\n\nВремя обработки. Автоматическое определение типов требует, чтобы Spark прочитал файл и проанализировал его содержимое для каждого столбца, чтобы определить соответствующие типы данных. Это добавляет дополнительные шаги в процесс чтения данных, что увеличивает общее время выполнения задачи.\n\nОшибки определения типов. Автоматическое определение типов не всегда корректно и может привести к неверному определению типов данных для некоторых столбцов. В дальнейшем, это может вызвать ошибки при обработке данных.\n\nЯвное задание схемы данных имеет несколько значительных преимуществ\nУскорение чтения данных. Когда схема данных задана явно, Spark не тратит время на анализ структуры данных. Это сокращает время чтения данных, особенно при работе с большими файлами.\n\nОптимизация плана выполнения. Явно заданная схема позволяет Spark лучше оптимизировать план выполнения, так как известны точные типы данных и структура таблиц. Это улучшает распределение задач и использование ресурсов.\n\nПредотвращение ошибок. С явно заданной схемой уменьшается риск ошибок, связанных с неправильным определением типов данных, что делает обработку данных более надёжной.\n\nСовместимость с другими инструментами. Явно заданная схема может быть легко интегрирована с другими инструментами и системами, что улучшает совместимость и упрощает обмен данными.\n\nРассмотрим пример чтения CSV-файла с явным заданием схемы данных.\n\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.types import StructType, StructField, StringType, IntegerType\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"SchemaExample\").getOrCreate()\n\n# Определение схемы данных\nschema = StructType([\n    StructField(\"name\", StringType(), True),\n    StructField(\"age\", IntegerType(), True),\n    StructField(\"city\", StringType(), True)\n])\n\n# Чтение CSV-файла с явно заданной схемой\ndf = spark.read.schema(schema).csv(\"path/to/file.csv\")\n\n# Показ первых 5 строк\ndf.show(5)\nВ этом примере:\n\nмы создаём SparkSession для работы с данными;\n\nопределяем схему данных с помощью StructType и StructField;\n\nчитаем CSV-файл с использованием явно заданной схемы;\n\nотображаем первые 5 строк для проверки.\n\nКэширование и персистенция\nКэширование и персистенция данных в Spark — важные инструменты повышения производительности. Они позволяют сохранять результаты промежуточных вычислений в памяти или на диске, чтобы вычисления не выполнялись повторно.\n\nКогда использовать cache(), а когда persist(), и как?\n\nИспользование cache():\n\nКогда требуется повторное использование одного и того же набора данных в нескольких последующих действиях (actions).\n\nПодходит для часто используемых данных, так как кэширование хранит данные в памяти (RAM), что ускоряет доступ.\n\nИспользование persist():\n\nКогда необходимо контролировать уровень хранения данных (например, в памяти, на диске или комбинации).\n\nПолезно для больших наборов данных, которые не помещаются целиком в память, или для обеспечения отказоустойчивости.\n\nРазличия между cache() и persist():\n\ncache(): эквивалентно вызову persist(StorageLevel.MEMORY_ONLY), хранит данные только в памяти.\n\npersist(): позволяет выбирать различные уровни хранения (Storage Levels) в зависимости от потребностей.\n\nУровни хранения:\n\nMEMORY_ONLY. Хранит данные только в памяти. Быстро, но требует много памяти.\n\nMEMORY_AND_DISK. Хранит данные в памяти, а если памяти недостаточно, сохраняет на диск.\n\nDISK_ONLY. Хранит данные только на диске. Медленнее, но экономит память.\n\nMEMORY_ONLY_SER. Хранит данные в памяти в сериализованном виде. Экономит память, но увеличивает затраты на сериализацию/десериализацию.\n\nMEMORY_AND_DISK_SER. Комбинация MEMORY_ONLY_SER и DISK_ONLY.\n\nПример с использованием cache().\n\nfrom pyspark.sql import SparkSession\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"CacheExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Кэширование DataFrame\ndf.cache()\n\n# Первое действие: подсчет строк\ncount = df.count()\nprint(f\"Total count: {count}\")\n\n# Второе действие: фильтрация данных\nfiltered_df = df.filter(df[\'age\'] > 30)\nfiltered_count = filtered_df.count()\nprint(f\"Filtered count: {filtered_count}\")\n\n# Отключение кэширования\ndf.unpersist()\n\n# Остановка SparkSession\nspark.stop()\nПример с использованием persist().\n\nfrom pyspark.sql import SparkSession\nfrom pyspark.storagelevel import StorageLevel\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"PersistExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Персистенция DataFrame с использованием уровня MEMORY_AND_DISK\ndf.persist(StorageLevel.MEMORY_AND_DISK)\n\n# Первое действие: подсчет строк\ncount = df.count()\nprint(f\"Total count: {count}\")\n\n# Второе действие: фильтрация данных\nfiltered_df = df.filter(df[\'age\'] > 30)\nfiltered_count = filtered_df.count()\nprint(f\"Filtered count: {filtered_count}\")\n\n# Отключение персистенции\ndf.unpersist()\n\n# Остановка SparkSession\nspark.stop()\nПримеры, показывающие разницу в производительности.\n\nfrom pyspark.sql import SparkSession\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"NoCacheExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Первое действие: подсчет строк (данные читаются заново)\ncount = df.count()\nprint(f\"Total count: {count}\")\n\n# Второе действие: фильтрация данных и подсчет строк (данные читаются заново)\nfiltered_df = df.filter(df[\'age\'] > 30)\nfiltered_count = filtered_df.count()\nprint(f\"Filtered count: {filtered_count}\")\n\n# Остановка SparkSession\nspark.stop()\nС кэшированием.\n\nfrom pyspark.sql import SparkSession\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"CacheExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Кэширование DataFrame\ndf.cache()\n\n# Первое действие: подсчет строк (данные читаются и кэшируются)\ncount = df.count()\nprint(f\"Total count: {count}\")\n\n# Второе действие: фильтрация данных и подсчет строк (данные берутся из кэша)\nfiltered_df = df.filter(df[\'age\'] > 30)\nfiltered_count = filtered_df.count()\nprint(f\"Filtered count: {filtered_count}\")\n\n# Отключение кэширования\ndf.unpersist()\n\n# Остановка SparkSession\nspark.stop()\nРазница в производительности.\n\nБез кэширования/персистенции. Для каждого действия (например, count или filter) Spark заново читает данные из исходного файла, что приводит к значительным временным затратам.\n\nС кэшированием/персистенцией. Данные читаются из исходного файла только один раз и сохраняются в памяти или на диске. Все последующие действия выполняются быстрее, так как данные берутся из кэша, минуя повторное чтение исходных данных.\n\nУправление партициями\nУправление партициями данных в Apache Spark — важная часть оптимизации производительности. Правильное разбиение данных на партиции позволяет эффективнее использовать ресурсы и ускоряет выполнение задач.\n\nРазбиение данных на партиции\nКогда данные загружаются в Spark, они автоматически разбиваются на партиции. \n\nПартиция — это логическая единица данных, которая обрабатывается одним узлом (node) в кластере Spark. Количество партиций по умолчанию зависит от источника данных и конфигурации Spark.\n\nКак правильно настроить количество партиций?\n\nНастройка количества партиций зависит от объёма данных и доступных ресурсов в кластере. Основные рекомендации включают:\n\nБаланс между партициями. Партиции должны быть примерно одинакового размера, чтобы равномерно распределить нагрузку между узлами.\n\nЧисло партиций. Обычное правило — иметь примерно 2-4 партиции на каждый CPU в кластере. Например, если у вас есть кластер с 8 узлами, каждый из которых имеет 4 CPU, то общее число партиций может быть от 64 до 128.\n\nРазмер партиции. Оптимальный размер обычно составляет от 128 MB до 1 GB.\n\nИспользование repartition и coalesce\nSpark предоставляет методы repartition и coalesce для изменения количества партиций.\n\nМетод repartition используется для увеличения или уменьшения количества партиций. Он выполняет shuffle данных, что может быть дорогостоящей операцией, но обеспечивает равномерное распределение данных между партициями.\n\nМетод coalesce используется для уменьшения количества партиций. Он выполняет это без shuffle данных, что делает его менее затратным по сравнению с repartition. Однако coalesce эффективен только для уменьшения количества партиций.\n\nПример разбиения данных на партиции при загрузке.\n\nfrom pyspark.sql import SparkSession\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"PartitioningExample\").getOrCreate()\n\n# Чтение данных из CSV-файла (по умолчанию разбивается на партиции)\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Проверка количества партиций\nprint(f\"Number of partitions: {df.rdd.getNumPartitions()}\")\nПример настройки количества партиций при загрузке данных.\n\n# Загрузка данных с указанием количества партиций\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True).repartition(100)\n\n# Проверка количества партиций\nprint(f\"Number of partitions after repartition: {df.rdd.getNumPartitions()}\")\nrepartition.\n\n# Увеличение количества партиций до 100\ndf_repartitioned = df.repartition(100)\n\n# Проверка количества партиций после repartition\nprint(f\"Number of partitions after repartition: {df_repartitioned.rdd.getNumPartitions()}\")\ncoalesce.\n\n# Уменьшение количества партиций до 10\ndf_coalesced = df.coalesce(10)\n\n# Проверка количества партиций после coalesce\nprint(f\"Number of partitions after coalesce: {df_coalesced.rdd.getNumPartitions()}\")\nПример использования repartition для увеличения числа партиций.\n\nfrom pyspark.sql import SparkSession\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"RepartitionExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Первоначальное количество партиций\nprint(f\"Initial number of partitions: {df.rdd.getNumPartitions()}\")\n\n# Увеличение количества партиций до 100\ndf_repartitioned = df.repartition(100)\n\n# Проверка количества партиций после repartition\nprint(f\"Number of partitions after repartition: {df_repartitioned.rdd.getNumPartitions()}\")\n\n# Остановка SparkSession\nspark.stop()\nПример использования coalesce для уменьшения числа партиций.\n\nfrom pyspark.sql import SparkSession\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"CoalesceExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Первоначальное количество партиций\nprint(f\"Initial number of partitions: {df.rdd.getNumPartitions()}\")\n\n# Уменьшение количества партиций до 10\ndf_coalesced = df.coalesce(10)\n\n# Проверка количества партиций после coalesce\nprint(f\"Number of partitions after coalesce: {df_coalesced.rdd.getNumPartitions()}\")\n\n# Остановка SparkSession\nspark.stop()\n№2. Оптимизация запросов\nОптимизация запросов в Apache Spark включает выбор правильных операций и понимание принципов, таких как ленивые вычисления. Давайте рассмотрим разницу между трансформациями (например, map, filter) и действиями (например, count, collect), а также то, как правильно выбирать операции для повышения производительности.\n\nВыбор правильных операций\nВ Spark все операции можно разделить на две категории: трансформации (transformations) и действия (actions).\n\nТрансформации\nЭто операции, которые создают новое распределенное множество данных (RDD) из существующего, но не выполняют никаких вычислений сразу. Трансформации являются ленивыми. Означает, что они не выполняются до тех пор, пока не будет вызвано действие.\n\nПример трансформации map.\n\nrdd = sc.parallelize([1, 2, 3, 4, 5])\nsquared_rdd = rdd.map(lambda x: x * x)\nfilter, flatMap, reduceByKey, groupByKey — это всё также трансформации.\n\nДействия\nЭто операции, которые запускают выполнение вычислений и возвращают результат. Действия требуют выполнения всех предшествующих трансформаций. \n\nПримерами действий являются count, collect, take, saveAsTextFile.\n\nПример действия count.\n\ncount = squared_rdd.count()\nprint(f\"Number of elements: {count}\")\nПринцип ленивых вычислений\nЛенивые вычисления (lazy evaluation) — это ключевой принцип Spark, который откладывает выполнение трансформаций до тех пор, пока не будет вызвано действие. Это позволяет Spark оптимизировать план выполнения, объединяя трансформации и минимизируя количество проходов по данным.\n\nПример.\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"LazyEvaluationExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Трансформации (ленивые вычисления)\nfiltered_df = df.filter(df[\'age\'] > 30)\nselected_df = filtered_df.select(\"name\", \"age\")\n\n# Действие (вызывает выполнение всех предыдущих трансформаций)\nresult = selected_df.collect()\n\n# Печать результатов\nfor row in result:\n    print(row)\n\n# Остановка SparkSession\nspark.stop()\nКак выбрать правильные операции? \nИспользовать трансформации вместо действий.\n\nПо возможности, избегайте вызова действий, которые собирают данные на драйвере (например, collect) на больших наборах данных, так как это может привести к перегрузке памяти. Вместо этого, используйте трансформации, чтобы минимизировать объём данных до вызова действия.\n\nПлохой пример: collect на больших данных.\n\nlarge_rdd = sc.parallelize(range(1000000))\ncollected_data = large_rdd.collect()  # Может привести к переполнению памяти\nХороший пример: уменьшение данных перед collect.\n\nfiltered_rdd = large_rdd.filter(lambda x: x % 2 == 0)\nsmall_collected_data = filtered_rdd.take(10)  # Безопаснее, так как собирается небольшой объём данных.\nИспользование map и flatMap\nИспользуйте map и flatMap для преобразования данных:\n\nmap применяется к каждому элементу RDD и возвращает новый RDD того же размера;\n\nflatMap может возвращать RDD различного размера.\n\nПример использования map.\n\nrdd = sc.parallelize([\"apple\", \"banana\", \"cherry\"])\nlength_rdd = rdd.map(lambda x: len(x))\nprint(length_rdd.collect())\nПример использования flatMap.\n\nwords_rdd = rdd.flatMap(lambda x: x.split(\"a\"))\nprint(words_rdd.collect())\nИспользование reduceByKey и groupByKey\nДля агрегации данных используйте reduceByKey вместо groupByKey, так как reduceByKey агрегирует данные локально на каждом узле перед пересылкой по сети, что уменьшает объём передаваемых данных.\n\nПример использования reduceByKey.\n\npairs = sc.parallelize([(\"a\", 1), (\"b\", 1), (\"a\", 1)])\nreduced_pairs = pairs.reduceByKey(lambda x, y: x + y)\nprint(reduced_pairs.collect())\nПример использования groupByKey (менее эффективно).\n\ngrouped_pairs = pairs.groupByKey()\nprint([(x, list(y)) for x, y in grouped_pairs.collect()])\nПример оптимизации запроса. \n\nРассмотрим пример, где мы хотим вычислить средний возраст пользователей старше 30 лет из CSV-файла.\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"QueryOptimizationExample\").getOrCreate()\n\n# Чтение данных из CSV-файла\ndf = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\n\n# Оптимизация запроса\n# Трансформации\nfiltered_df = df.filter(df[\'age\'] > 30)\nage_sum = filtered_df.groupBy().sum(\"age\")\nage_count = filtered_df.groupBy().count()\n\n# Действие: выполнение всех трансформаций и получение результата\nsum_age = age_sum.collect()[0][0]\ncount_age = age_count.collect()[0][0]\n\naverage_age = sum_age / count_age\nprint(f\"Average age: {average_age}\")\n\n# Остановка SparkSession\nspark.stop()\nВ этом примере мы минимизируем объём данных, применяя фильтрацию перед агрегацией и избегаем излишних действий. Все трансформации объединяются и выполняются вместе при вызове действия, что позволяет Spark оптимизировать выполнение запроса.\n\nПорядок выполнения операций\nПравильный порядок выполнения операций в Spark существенно влияет на производительность приложений. В частности, выполнение фильтрации и агрегации до операций соединения (join) и стратегический подход к построению запросов от меньших таблиц к большим может значительно улучшить эффективность обработки данных.\n\nПочему важно выполнять фильтрацию и агрегацию до соединений?\nСокращение объёма данных: Фильтрация и агрегация уменьшают количество данных, которые нужно обрабатывать при последующем соединении. Это снижает затраты на передачу данных по сети и уменьшает объём данных, участвующих в операции соединения.\n\nУменьшение ресурсов: Меньшие объёмы данных требуют меньше ресурсов для хранения и обработки, что позволяет более эффективно использовать вычислительные ресурсы.\n\nСокращение времени выполнения: Обработка меньших объёмов данных быстрее и эффективнее, что сокращает общее время выполнения запроса.\n\nПример выполнения фильтрации и агрегации до соединений.\n\nfrom pyspark.sql import SparkSession\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"OptimizationExample\").getOrCreate()\n\n# Пример данных\ndata1 = [(\"Alice\", 34, \"HR\"), (\"Bob\", 45, \"IT\"), (\"Charlie\", 29, \"HR\"), (\"David\", 40, \"Finance\")]\ndata2 = [(\"HR\", \"Human Resources\"), (\"IT\", \"Information Technology\"), (\"Finance\", \"Financial Department\")]\n\ndf1 = spark.createDataFrame(data1, [\"name\", \"age\", \"dept\"])\ndf2 = spark.createDataFrame(data2, [\"dept\", \"department_name\"])\n\n# Фильтрация до соединения\nfiltered_df1 = df1.filter(df1[\'age\'] > 30)\n\n# Соединение\njoined_df = filtered_df1.join(df2, filtered_df1.dept == df2.dept)\n\n# Показ результатов\njoined_df.show()\n\n# Остановка SparkSession\nspark.stop()\nВ этом примере сначала фильтруются данные df1, чтобы оставить только записи с возрастом больше 30. Только после этого выполняется соединение с df2. Такая последовательность позволяет уменьшить объём данных, участвующих в соединении, и улучшает производительность.\n\nСтратегии построения запросов от меньших таблиц к большим\nПочему это важно?\n\nЭффективное использование памяти. Начало с меньших таблиц помогает избежать проблем с нехваткой памяти, так как меньшие объёмы данных проще обрабатывать и кэшировать.\n\nУменьшение количества shuffle. Соединение меньших таблиц до более крупных уменьшает объём shuffle данных, что улучшает производительность сети и общее время выполнения.\n\nБолее быстрый доступ к результатам. Обработка меньших таблиц позволяет быстрее получить промежуточные результаты, которые могут быть использованы для дальнейших операций.\n\nПример стратегии построения запросов.\n\nРассмотрим пример, где нужно выполнить несколько соединений, начиная с меньших таблиц.\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"JoinOptimizationExample\").getOrCreate()\n\n# Пример данных\ndata_small = [(\"Alice\", 34, \"HR\"), (\"Bob\", 45, \"IT\")]\ndata_medium = [(\"HR\", \"Human Resources\"), (\"IT\", \"Information Technology\"), (\"Finance\", \"Financial Department\")]\ndata_large = [(\"HR\", 1), (\"IT\", 2), (\"Finance\", 3), (\"HR\", 4), (\"IT\", 5), (\"Finance\", 6)]\n\ndf_small = spark.createDataFrame(data_small, [\"name\", \"age\", \"dept\"])\ndf_medium = spark.createDataFrame(data_medium, [\"dept\", \"department_name\"])\ndf_large = spark.createDataFrame(data_large, [\"dept\", \"id\"])\n\n# Соединение маленькой таблицы с средней\njoined_small_medium = df_small.join(df_medium, \"dept\")\n\n# Фильтрация после первого соединения\nfiltered_join = joined_small_medium.filter(joined_small_medium[\'age\'] > 30)\n\n# Соединение с большой таблицей\nfinal_join = filtered_join.join(df_large, \"dept\")\n\n# Показ результатов\nfinal_join.show()\n\n# Остановка SparkSession\nspark.stop()\nВ этом примере:\n\nСоединение маленькой таблицы со средней. Сначала соединяем df_small и df_medium. Это небольшие таблицы, поэтому операция соединения выполняется быстро и требует меньше ресурсов.\n\nФильтрация после первого соединения. После первого соединения выполняем фильтрацию, оставляя только записи с возрастом больше 30. Это ещё больше уменьшает объём данных.\n\nСоединение с большой таблицей. Только после уменьшения объёма данных соединяем результат с большой таблицей df_large.\n\nРазличные стратегии для уменьшения данных до соединения\nИспользование агрегации. Выполнение агрегации до соединения, чтобы уменьшить объём данных.\n\nИспользование транзитивных свойств. Например, если у вас есть три таблицы и вам нужно соединить их, сначала соединяйте меньшие таблицы.\n\nКэширование. Кэширование промежуточных результатов, чтобы избежать повторного вычисления и уменьшить нагрузку на систему.\n\nПример использования агрегации перед соединением.\n\n# Создание SparkSession\nspark = SparkSession.builder.appName(\"AggregationBeforeJoinExample\").getOrCreate()\n\n# Пример данных\ndata1 = [(\"Alice\", 34, \"HR\"), (\"Bob\", 45, \"IT\"), (\"Charlie\", 29, \"HR\"), (\"David\", 40, \"Finance\"), (\"Eve\", 50, \"IT\")]\ndata2 = [(\"HR\", \"Human Resources\"), (\"IT\", \"Information Technology\"), (\"Finance\", \"Financial Department\")]\n\ndf1 = spark.createDataFrame(data1, [\"name\", \"age\", \"dept\"])\ndf2 = spark.createDataFrame(data2, [\"dept\", \"department_name\"])\n\n# Агрегация до соединения (средний возраст по департаментам)\nagg_df1 = df1.groupBy(\"dept\").avg(\"age\").alias(\"avg_age\")\n\n# Соединение с таблицей департаментов\njoined_df = agg_df1.join(df2, \"dept\")\n\n# Показ результатов\njoined_df.show()\n\n# Остановка SparkSession\nspark.stop()\nВ этом примере мы сначала выполняем агрегацию для вычисления среднего возраста по департаментам, а затем соединяем результаты с таблицей департаментов. Это уменьшает объём данных, участвующих в соединении, и улучшает производительность.\n\nЗаключение\nНадеюсь, эта статья помогла вам разобраться в основах оптимизации производительности Apache Spark и ответила на некоторые ваши вопросы. Удачи в работе с данными!',
        '2024-07-18 14:33:54', '2024-07-18 18:47:27', 1),
       (26, 1, 'Новая модель GPT-4o mini от OpenAI будет заменой GPT-3.5 и уже доступна\n', NULL,
        'Произошел ранний выход запланированной новости на CNBC, новость также появилась на Reuters. и уже есть подтверждение в блоге OpenAI\n\nOpenAI назвала новый релиз «самой умной и экономически эффективной малой моделью, доступной на сегодняшний день». Согласно утечке, она будет в 2.5 раза дешевле и так недорогой последней модели ChatGPT-3.5, и, вероятно, будет её основной заменой. В модель также планируется интегрировать обработку изображений, видео и аудио.\n\nМини‑модель ИИ является упрощенной версией GPT-4o, самой быстрой и мощной модели OpenAI на сегодняшний день, которую компания запустила в мае во время прямой трансляции с участием руководителей.\n\nСогласно пресс‑релизу GPT-4o mini будет доступна в четверг для бесплатных пользователей ChatGPT, а также для подписчиков ChatGPT Plus и Team, и станет доступна для пользователей ChatGPT Enterprise на следующей неделе, сообщила компания в пресс‑релизе.\n\nПоскольку я пилю сервис VseGPT для доступа к разным сетям (GPT-4o, Sonnet 3.5 и пр.) по OpenAI API и через вебчат, то, конечно, постараюсь подключить модель в самые короткие сроки, как только она станет доступна. уже подключил модель :)\n\nСтатья будет дополняться по мере выхода подробностей.\n\nUPD1: Вышел официальный пост в блоге OpenAI с сравнением с другими моделями. GPT-4o-mini опережает все модели... кроме изначальной GPT-4o\n\n\nТакже замечено, что, как всегда, было уделено внимание фильтрации неэтичных данных: «При предварительном обучении мы отфильтровывали информацию, которую не хотим, чтобы наши модели изучали: язык ненависти, контент для взрослых, сайты, которые в основном собирают личную информацию, и спам.»\n\nUPD2 (21:43): Модель доступна по API OpenAI API и у меня на сервисе VseGPT, который проксирует вызовы к OpenAI. Сейчас будем тестировать :)',
        '2024-07-18 14:33:54', '2024-07-18 18:47:56', 1),
       (27, 1, 'Когда встретился с проблемой nullptr! = NULL лицом к лицу\n', NULL,
        'Многие из нас частенько читают статьи о багах и лучших практиках программирования, чтобы избежать возможных ошибок. Порой, ты просто знаешь, как не нужно делать, но на практике с реальной проблемой не встречаешься. Для меня такой была тема nullptr != NULL. Изначально NULL я использовала в системном программировании на Си. При переходе на C++, макрос NULL встречала только в WinAPI, в коде для null-указателей всегда использовала nullptr (все уже выучили, что nullptr != NULL). С реальными последствиями, где NULL используется вместо nullptr, мне не доводилось встречаться. Так было до замены boost::function на std::function в одном компоненте.\n\nРабочий день начинался стандартно с анализа новых аварийных дампов. Вот появилась пачка дампов одного сервиса. Выглядит обычно: произошёл вызов колбэка, когда объект уже разрушен. Скорее всего забыли отписаться от события при шатдауне, нужно это делать явно. Завели на это баг. \n\nError(s):\nterminate called after throwing an instance of \'boost::exception_detail::clone_impl<boost::exception_detail::error_info_injector<boost::bad_function_call> >\'\n  what():  call to empty boost::function\nВ течение трех дней подобная ситуация появилась ещё в нескольких сервисах. Значит, проблема не просто в отсутствии отписки. Нужно понять причину массовой проблемы и оценить масштаб. На днях должны сбилдить релиз‑кандидат, массовые крешдампы не допустимы. Уже несколько недель идёт обычный багфикс, никаких глобальных изменений не должно быть. Проверяю почту рассылок: на днях обновили версию одного компонента, от которого есть зависимость у всех упавших сервисов. Сроки релиза продукта и компонента разные, поэтому интеграция произошла довольно поздно. В компоненте много изменений, но все они относятся к замене boost::function на std::function.\n\nПроверяю код отписки от событий в упавших сервисах. Вижу какой‑то непонятный код. Сначала не сразу соображаешь, что это и есть код отписки:\n\nconnection.SetCallback(boost::function<void(bool)>());\n что эквивалентно:\n\nconnection.SetCallback(NULL);\n В реализации connection при возникновении события, вызывается колбэк-функция.\n\nИспользование boost::function в компоненте:\n\nvoid SetCallback(boost::function<void(bool)> callback)\n{\n   ...\n}\n\nvoid ConnectionChanged(bool state)\n{\n    if (!_callback.empty())\n	{\n        _сallback(state);\n	    // do something\n	}\n}\nПосле перевода компонента на std:\n\nvoid SetCallback(std::function<void(bool)> callback)\n{\n   ...\n}\n\nvoid ConnectionChanged(bool state)\n{\n    if (_callback != nullptr)\n	{\n        _сallback(state);\n	    // do something\n	}\n}\nПричем если в качестве колбэка в SetCallback передать явно NULL, для случая с std::function ошибка обнаружится уже на этапе компиляции. А вот при отписке с использованием дефолтного конструктора boost::function() ошибка обнаруживается при исполнении кода. connection.SetCallback(boost::function<void(bool)>()) теперь не выполняет отписку, а устанавливает NULL как колбэка. В методе ConnectionChanged колбэк проходит проверку на nullptr, вызов фактически пустого колбэка приводит к исключению boost::bad_function_call. Причиной нарушения обратной совместимости стало то, что для boost::function конструктор по умолчанию возвращает NULL, а для std::function — nullptr.\n\nПоиск по всей кодовой базе показал, что подобную форму отписки делают в десятках компонент. Если не поправить весь код, будет появляться много дампов: при выключении устройств и смене режимов работы (требуется перезагрузка сервисов). Перспективы так себе. Единственное предложение, которое можно было рекомендовать, это отложить релиз на неделю и все поправить в коде. Предложение одобрили. Все команды выделили людей для исправления кода.\n\nПроблема была решена, но потребовала сдвиг сроков релиза. После этого случая компонент стали проверять на обратную совместимость (делали ревью кода) перед обновлением до новой версии. Теперь интеграция всегда откладывалась до начала следующего релиза.\n\nДумаю, случай нечастый, но тоже можно встретить на просторах кодобазы.',
        '2024-07-18 14:33:54', '2024-07-18 18:48:12', 1),
       (30, 1, 'Как сделать ограничение по вводу символов в textarea?',
        'Устанавливает максимальное число символов, которое может быть введено пользователем в текстовом поле. Когда это количество достигается при наборе, дальнейший ввод становится невозможным.',
        'Описание\r\nУстанавливает максимальное число символов, которое может быть введено пользователем в текстовом поле. Когда это количество достигается при наборе, дальнейший ввод становится невозможным.\r\n\r\nСинтаксис\r\nHTML	\r\n<input type=\"text\" maxlength=\"число\">\r\n<input type=\"password\" maxlength=\"число\">\r\nXHTML	\r\n<input type=\"text\" maxlength=\"число\" />\r\n<input type=\"password\" maxlength=\"число\" />\r\nЗначения\r\nЛюбое целое положительное число.\r\n\r\nЗначение по умолчанию\r\nВвод символов не ограничен.\r\n\r\nПример\r\n\r\nHTML5IECrOpSaFx\r\n\r\n<!DOCTYPE HTML>\r\n<html>\r\n <head>\r\n  <meta charset=\"utf-8\">\r\n  <title>Тег INPUT, атрибут maxlength</title>\r\n </head>\r\n <body>\r\n\r\n  <form  action=\"handler.php\">\r\n   <p><input type=\"text\" size=\"30\" maxlength=\"10\"></p>\r\n   <p><input type=\"submit\" name=\"submit\" value=\"Отправить\"></p>\r\n  </form> \r\n\r\n </body>\r\n</html>',
        '2024-07-18 19:23:57', '2024-07-18 19:23:57', 1);

-- --------------------------------------------------------

--
-- Структура таблицы `users`
--

CREATE TABLE `users`
(
    `id`               int UNSIGNED NOT NULL,
    `username`         varchar(255) NOT NULL,
    `full_name`        varchar(255) NOT NULL,
    `link_to_photo`    varchar(255)          DEFAULT NULL,
    `email`            varchar(255) NOT NULL,
    `phone`            varchar(20)           DEFAULT NULL,
    `job`              varchar(255)          DEFAULT NULL,
    `location_city`    varchar(255)          DEFAULT NULL,
    `location_country` varchar(255)          DEFAULT NULL,
    `social_website`   varchar(255)          DEFAULT NULL,
    `social_github`    varchar(255)          DEFAULT NULL,
    `social_vk`        varchar(255)          DEFAULT NULL,
    `social_telegram`  varchar(255)          DEFAULT NULL,
    `password_hash`    varchar(255) NOT NULL,
    `salt`             varchar(32)  NOT NULL,
    `created_at`       timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `updated_at`       timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    `is_author`        tinyint(1) NOT NULL DEFAULT '0',
    `is_admin`         tinyint(1) NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3;

--
-- Дамп данных таблицы `users`
--

INSERT INTO `users` (`id`, `username`, `full_name`, `link_to_photo`, `email`, `phone`, `job`, `location_city`,
                     `location_country`, `social_website`, `social_github`, `social_vk`, `social_telegram`,
                     `password_hash`, `salt`, `created_at`, `updated_at`, `is_author`, `is_admin`)
VALUES (1, 'bthompson', 'Bob Thompson', 'https://github.githubassets.com/assets/pull-shark-default-498c279a747d.png',
        'admin@mail.com', '345-678-9012', 'Manager, Admin', 'Toronto', 'Canada', 'https://bobthompson.com',
        'https://github.com/bobthompson', 'https://vk.com/bobthompson', 'bobthompson',
        'b1bf4e915954747316564d958a501a693528e7cc5360fdd9efa33b487f2c7345', 'bec8ac4a0227e26acbd2ccf63af6eb56',
        '2024-07-15 18:28:38', '2024-07-18 14:33:50', 1, 1),
       (2, 'asmith', 'Alice Smith',
        'https://fikiwiki.com/uploads/posts/2022-02/1644852415_12-fikiwiki-com-p-kartinki-admina-12.png',
        'asmith@example.com', '234-567-8901', 'Designer', 'London', 'UK', 'https://alicesmith.com',
        'https://github.com/alicesmith', 'https://vk.com/alicesmith', 'https://t.me/alicesmith',
        '2de3c0eb7f7e2414a13bdaa5a56f1e5a66a7dbdaf6c576976ba4e3eb0be2fa4b', '392ae3280f1d45bd5ffc20602a92dc0e',
        '2024-07-15 18:28:38', '2024-07-15 18:28:38', 0, 0);

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `articles`
--
ALTER TABLE `articles`
    ADD PRIMARY KEY (`id`),
  ADD KEY `user_id` (`user_id`);

--
-- Индексы таблицы `users`
--
ALTER TABLE `users`
    ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `email` (`email`),
  ADD UNIQUE KEY `phone` (`phone`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `articles`
--
ALTER TABLE `articles`
    MODIFY `id` int UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=31;

--
-- AUTO_INCREMENT для таблицы `users`
--
ALTER TABLE `users`
    MODIFY `id` int UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;

--
-- Ограничения внешнего ключа сохраненных таблиц
--

--
-- Ограничения внешнего ключа таблицы `articles`
--
ALTER TABLE `articles`
    ADD CONSTRAINT `articles_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
